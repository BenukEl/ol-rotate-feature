{"version":3,"file":"bundle.min.js","sources":["../src/util.js","../src/event.js","../src/interaction.js","../src/index.js"],"sourcesContent":["/**\n * @param {boolean} condition\n * @param {string} message\n * @throws Error\n */\nexport function assert (condition, message = '') {\n  message = [ 'Assertion failed', message ].join(': ')\n\n  if (!condition) {\n    throw new Error(message)\n  }\n}\n\n/**\n * @param {*} arg\n * @returns {*}\n */\nexport function identity (arg) {\n  return arg\n}\n\n/**\n * @param {...*} args\n * @return {*}\n */\nexport function coalesce (...args) {\n  return args.filter(value => value != null).shift()\n}\n\nconst counters = {}\n/**\n * @param {string} [prefix]\n * @return {number}\n */\nexport function uniqId (prefix = '') {\n  const ns = prefix || 'default'\n  counters[ ns ] = counters[ ns ] == null ? 0 : counters[ ns ]\n\n  return String(prefix) + (++counters[ ns ])\n}\n\nexport function includes (arr, value) {\n  return arr.indexOf(value) !== -1\n}\n\nexport function isArray (val) {\n  return val::Object.prototype.toString() === '[object Array]'\n}\n","/**\n * @enum {string}\n */\nexport const RotateFeatureEventType = {\n  /**\n   * Triggered upon feature rotate start.\n   * @event RotateFeatureEvent#rotatestart\n   */\n  START: 'rotatestart',\n  /**\n   * Triggered upon feature rotation.\n   * @event RotateFeatureEvent#rotating\n   */\n  ROTATING: 'rotating',\n  /**\n   * Triggered upon feature rotation end.\n   * @event RotateFeatureEvent#rotateend\n   */\n  END: 'rotateend'\n}\n\n/**\n * Events emitted by RotateFeatureInteraction instances are instances of this type.\n *\n * @class\n * @author Vladimir Vershinin\n */\nexport default class RotateFeatureEvent {\n  /**\n   * @param {string} type Type.\n   * @param {ol.Collection<ol.Feature>} features Rotated features.\n   * @param {number} angle Angle in radians.\n   * @param {ol.Coordinate} anchor Anchor position.\n   */\n  constructor (type, features, angle, anchor) {\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.propagationStopped_ = false\n\n    /**\n     * The event type.\n     * @type {string}\n     * @private\n     */\n    this.type_ = type\n\n    /**\n     * The features being rotated.\n     * @type {ol.Collection<ol.Feature>}\n     * @private\n     */\n    this.features_ = features\n    /**\n     * Current angle in radians.\n     * @type {number}\n     * @private\n     */\n    this.angle_ = angle\n    /**\n     * Current rotation anchor.\n     * @type {ol.Coordinate}\n     * @private\n     */\n    this.anchor_ = anchor\n  }\n\n  /**\n   * @type {boolean}\n   */\n  get propagationStopped () {\n    return this.propagationStopped_\n  }\n\n  /**\n   * @type {RotateFeatureEventType}\n   */\n  get type () {\n    return this.type_\n  }\n\n  /**\n   * @type {ol.Collection<ol.Feature>}\n   */\n  get features () {\n    return this.features_\n  }\n\n  /**\n   * @type {number}\n   */\n  get angle () {\n    return this.angle_\n  }\n\n  /**\n   * @type {ol.Coordinate}\n   */\n  get anchor () {\n    return this.anchor_\n  }\n\n  /**\n   * Prevent event propagation.\n   */\n  preventDefault () {\n    this.propagationStopped_ = true\n  }\n\n  /**\n   * Stop event propagation.\n   */\n  stopPropagation () {\n    this.propagationStopped_ = true\n  }\n}\n","/**\n * Rotate interaction class.\n * Adds controls to rotate vector features.\n * Writes out total angle in radians (positive is counter-clockwise) to property for each feature.\n */\nimport PointerInteraction from 'ol/interaction/pointer'\nimport Collection from 'ol/collection'\nimport VectorLayer from 'ol/layer/vector'\nimport VectorSource from 'ol/source/vector'\nimport Feature from 'ol/feature'\nimport Point from 'ol/geom/point'\nimport Polygon from 'ol/geom/polygon'\nimport GeometryCollection from 'ol/geom/geometrycollection'\nimport Style from 'ol/style/style'\nimport RegularShape from 'ol/style/regularshape'\nimport Stroke from 'ol/style/stroke'\nimport Fill from 'ol/style/fill'\nimport Text from 'ol/style/text'\nimport extentHelper from 'ol/extent'\nimport { assert, identity, includes, isArray } from './util'\nimport RotateFeatureEvent, { RotateFeatureEventType } from './event'\n\nconst ANCHOR_KEY = 'rotate-anchor'\nconst ARROW_KEY = 'rotate-arrow'\n\nconst ANGLE_PROP = 'angle'\nconst ANCHOR_PROP = 'anchor'\n\n/**\n * @todo todo добавить опцию condition - для возможности переопределения клавиш\n */\nexport default class RotateFeatureInteraction extends PointerInteraction {\n  /**\n   * @param {InteractionOptions} options\n   */\n  constructor (options = {}) {\n    super({\n      handleEvent: handleEvent,\n      handleDownEvent: handleDownEvent,\n      handleUpEvent: handleUpEvent,\n      handleDragEvent: handleDragEvent,\n      handleMoveEvent: handleMoveEvent\n    })\n    /**\n     * @type {string}\n     * @private\n     */\n    this.previousCursor_ = undefined\n    /**\n     * @type {ol.Feature}\n     * @private\n     */\n    this.anchorFeature_ = undefined\n    /**\n     * @type {ol.Feature}\n     * @private\n     */\n    this.arrowFeature_ = undefined\n    /**\n     * @type {ol.Coordinate}\n     * @private\n     */\n    this.lastCoordinate_ = undefined\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.anchorMoving_ = false\n    /**\n     * @type {ol.layer.Vector}\n     * @private\n     */\n    this.overlay_ = new VectorLayer({\n      style: options.style || getDefaultStyle(),\n      source: new VectorSource({\n        features: new Collection()\n      })\n    })\n    /**\n     * @type {ol.Collection<ol.Feature>}\n     * @private\n     */\n    this.features_ = undefined\n    if (options.features) {\n      if (isArray(options.features)) {\n        this.features_ = new Collection(options.features)\n      } else if (options.features instanceof Collection) {\n        this.features_ = options.features\n      } else {\n        throw new Error('Features option should be an array or collection of features, ' +\n                        'got ' + (typeof options.features))\n      }\n    } else {\n      this.features_ = new Collection()\n    }\n\n    this.setAnchor(options.anchor || getFeaturesCentroid(this.features_))\n    this.setAngle(options.angle || 0)\n\n    this.features_.on('add', ::this.onFeatureAdd_)\n    this.features_.on('remove', ::this.onFeatureRemove_)\n    this.on('change:' + ANGLE_PROP, ::this.onAngleChange_)\n    this.on('change:' + ANCHOR_PROP, ::this.onAnchorChange_)\n\n    this.createOrUpdateAnchorFeature_()\n    this.createOrUpdateArrowFeature_()\n  }\n\n  /**\n   * @type {ol.Collection<ol.Feature>}\n   */\n  get features () {\n    return this.features_\n  }\n\n  /**\n   * @type {number}\n   */\n  get angle () {\n    return this.getAngle()\n  }\n\n  /**\n   * @param {number} angle\n   */\n  set angle (angle) {\n    this.setAngle(angle)\n  }\n\n  /**\n   * @type {ol.Coordinate|undefined}\n   */\n  get anchor () {\n    return this.getAnchor()\n  }\n\n  /**\n   * @param {ol.Coordinate|undefined} anchor\n   */\n  set anchor (anchor) {\n    this.setAnchor(anchor)\n  }\n\n  /**\n   * @param {ol.Map} map\n   */\n  set map (map) {\n    this.setMap(map)\n  }\n\n  /**\n   * @type {ol.Map}\n   */\n  get map() {\n    return this.getMap()\n  }\n\n  /**\n   * @param {boolean} active\n   */\n  set active (active) {\n    this.setActive(active)\n  }\n\n  /**\n   * @type {boolean}\n   */\n  get active () {\n    return this.getActive()\n  }\n\n  /**\n   * @param {ol.Map} map\n   */\n  setMap (map) {\n    this.overlay_.setMap(map)\n    super.setMap(map)\n  }\n\n  /**\n   * @param {boolean} active\n   */\n  setActive (active) {\n    if (this.overlay_) {\n      this.overlay_.setMap(active ? this.map : undefined)\n    }\n\n    super.setActive(active)\n  }\n\n  /**\n   * Set current angle of interaction features.\n   *\n   * @param {number} angle\n   */\n  setAngle (angle) {\n    assert(!isNaN(parseFloat(angle)), 'Numeric value passed')\n\n    this.set(ANGLE_PROP, parseFloat(angle))\n  }\n\n  /**\n   * Returns current angle of interaction features.\n   *\n   * @return {number}\n   */\n  getAngle () {\n    return this.get(ANGLE_PROP)\n  }\n\n  /**\n   * Set current anchor position.\n   *\n   * @param {ol.Coordinate | undefined} anchor\n   */\n  setAnchor (anchor) {\n    assert(anchor == null || isArray(anchor) && anchor.length === 2, 'Array of two elements passed')\n\n    this.set(ANCHOR_PROP, anchor != null ? anchor.map(parseFloat) : getFeaturesCentroid(this.features_))\n  }\n\n  /**\n   * Returns current anchor position.\n   *\n   * @return {ol.Coordinate | undefined}\n   */\n  getAnchor () {\n    return this.get(ANCHOR_PROP)\n  }\n\n  /**\n   * @private\n   */\n  createOrUpdateAnchorFeature_ () {\n    const angle = this.getAngle()\n    const anchor = this.getAnchor()\n\n    if (!anchor) return\n\n    if (this.anchorFeature_) {\n      this.anchorFeature_.getGeometry().setCoordinates(anchor)\n      this.anchorFeature_.set(ANGLE_PROP, angle)\n    } else {\n      this.anchorFeature_ = new Feature({\n        geometry: new Point(anchor),\n        [ ANGLE_PROP ]: angle,\n        [ ANCHOR_KEY ]: true\n      })\n      this.overlay_.getSource().addFeature(this.anchorFeature_)\n    }\n  }\n\n  /**\n   * @private\n   */\n  createOrUpdateArrowFeature_ () {\n    const angle = this.getAngle()\n    const anchor = this.getAnchor()\n\n    if (!anchor) return\n\n    if (this.arrowFeature_) {\n      this.arrowFeature_.getGeometry().setCoordinates(anchor)\n      this.arrowFeature_.set(ANGLE_PROP, angle)\n    } else {\n      this.arrowFeature_ = new Feature({\n        geometry: new Point(anchor),\n        [ ANGLE_PROP ]: angle,\n        [ ARROW_KEY ]: true\n      })\n      this.overlay_.getSource().addFeature(this.arrowFeature_)\n    }\n  }\n\n  /**\n   * @private\n   */\n  resetAngleAndAnchor_() {\n    this.resetAngle_();\n    this.resetAnchor_();\n  }\n\n  /**\n   * @private\n   */\n  resetAngle_() {\n    this.set(ANGLE_PROP, 0, true);\n    this.arrowFeature_ && this.arrowFeature_.set(ANGLE_PROP, this.getAngle());\n    this.anchorFeature_ && this.anchorFeature_.set(ANGLE_PROP, this.getAngle());\n  }\n\n  /**\n   * @private\n   */\n  resetAnchor_() {\n    this.set(ANCHOR_PROP, getFeaturesCentroid(this.features_), true);\n\n    if (this.getAnchor()) {\n      this.arrowFeature_ && this.arrowFeature_.getGeometry().setCoordinates(this.getAnchor());\n      this.anchorFeature_ && this.anchorFeature_.getGeometry().setCoordinates(this.getAnchor());\n    }\n  }\n\n  /**\n   * @private\n   */\n  onFeatureAdd_ () {\n    this.resetAngleAndAnchor_()\n    this.createOrUpdateAnchorFeature_()\n    this.createOrUpdateArrowFeature_()\n  }\n\n  /**\n   * @private\n   */\n  onFeatureRemove_ () {\n    this.resetAngleAndAnchor_()\n\n    if (this.features_.getLength()) {\n      this.createOrUpdateAnchorFeature_()\n      this.createOrUpdateArrowFeature_()\n    } else {\n      this.overlay_.getSource().clear()\n      this.anchorFeature_ = this.arrowFeature_ = undefined\n    }\n  }\n\n  /**\n   * @private\n   */\n  onAngleChange_({ oldValue }) {\n    this.features_.forEach(feature => feature.getGeometry().rotate(this.getAngle() - oldValue, this.getAnchor()))\n    this.arrowFeature_ && this.arrowFeature_.set(ANGLE_PROP, this.getAngle())\n    this.anchorFeature_ && this.anchorFeature_.set(ANGLE_PROP, this.getAngle())\n  }\n\n  /**\n   * @private\n   */\n  onAnchorChange_() {\n    const anchor = this.getAnchor()\n\n    if (anchor) {\n      this.anchorFeature_ && this.anchorFeature_.getGeometry().setCoordinates(anchor)\n      this.arrowFeature_ && this.arrowFeature_.getGeometry().setCoordinates(anchor)\n    }\n  }\n\n  /**\n   * @param {ol.Collection<ol.Feature>} features\n   * @private\n   */\n  dispatchRotateStartEvent_ (features) {\n    this.dispatchEvent(\n      new RotateFeatureEvent(\n        RotateFeatureEventType.START,\n        features,\n        this.getAngle(),\n        this.getAnchor()\n      )\n    )\n  }\n\n  /**\n   * @param {ol.Collection<ol.Feature>} features\n   * @private\n   */\n  dispatchRotatingEvent_ (features) {\n    this.dispatchEvent(\n      new RotateFeatureEvent(\n        RotateFeatureEventType.ROTATING,\n        features,\n        this.getAngle(),\n        this.getAnchor()\n      )\n    )\n  }\n\n  /**\n   * @param {ol.Collection<ol.Feature>} features\n   * @private\n   */\n  dispatchRotateEndEvent_ (features) {\n    this.dispatchEvent(\n      new RotateFeatureEvent(\n        RotateFeatureEventType.END,\n        features,\n        this.getAngle(),\n        this.getAnchor()\n      )\n    )\n  }\n}\n\n/**\n * @param {ol.MapBrowserEvent} evt Map browser event.\n * @return {boolean} `false` to stop event propagation.\n * @this {RotateFeatureInteraction}\n * @private\n */\nfunction handleEvent (evt) {\n  // disable selection of inner features\n  const foundFeature = evt.map.forEachFeatureAtPixel(evt.pixel, identity)\n  if (\n    includes([ 'click', 'singleclick', 'dblclick' ], evt.type) &&\n    includes([ this.anchorFeature_, this.arrowFeature_ ], foundFeature)\n  ) {\n    return false\n  }\n\n  return this::PointerInteraction.handleEvent(evt)\n}\n\n/**\n * @param {ol.MapBrowserEvent} evt Event.\n * @return {boolean}\n * @this {RotateFeatureInteraction}\n * @private\n */\nfunction handleDownEvent (evt) {\n  const foundFeature = evt.map.forEachFeatureAtPixel(evt.pixel, identity)\n\n  // handle click & drag on features for rotation\n  if (\n    foundFeature && !this.lastCoordinate_ &&\n    (\n      includes(this.features_.getArray(), foundFeature) ||\n      foundFeature === this.arrowFeature_\n    )\n  ) {\n    this.lastCoordinate_ = evt.coordinate\n\n    this::handleMoveEvent(evt)\n    this.dispatchRotateStartEvent_(this.features_)\n\n    return true\n  }\n  // handle click & drag on rotation anchor feature\n  else if (foundFeature && foundFeature === this.anchorFeature_) {\n    this.anchorMoving_ = true\n    this::handleMoveEvent(evt)\n\n    return true\n  }\n\n  return false\n}\n\n/**\n * @param {ol.MapBrowserEvent} evt Event.\n * @return {boolean}\n * @this {RotateFeatureInteraction}\n * @private\n */\nfunction handleUpEvent (evt) {\n  // stop drag sequence of features\n  if (this.lastCoordinate_) {\n    this.lastCoordinate_ = undefined\n\n    this::handleMoveEvent(evt)\n    this.dispatchRotateEndEvent_(this.features_)\n\n    return true\n  }\n  // stop drag sequence of the anchors\n  else if (this.anchorMoving_) {\n    this.anchorMoving_ = false\n    this::handleMoveEvent(evt)\n\n    return true\n  }\n\n  return false\n}\n\n/**\n * @param {ol.MapBrowserEvent} evt Event.\n * @return {boolean}\n * @this {RotateFeatureInteraction}\n * @private\n */\nfunction handleDragEvent ({ coordinate }) {\n  const anchorCoordinate = this.anchorFeature_.getGeometry().getCoordinates()\n\n  // handle drag of features by angle\n  if (this.lastCoordinate_) {\n    // calculate vectors of last and current pointer positions\n    const lastVector = [\n      this.lastCoordinate_[ 0 ] - anchorCoordinate[ 0 ],\n      this.lastCoordinate_[ 1 ] - anchorCoordinate[ 1 ]\n    ]\n    const newVector = [\n      coordinate[ 0 ] - anchorCoordinate[ 0 ],\n      coordinate[ 1 ] - anchorCoordinate[ 1 ]\n    ]\n\n    // calculate angle between last and current vectors (positive angle counter-clockwise)\n    let angle = Math.atan2(\n      lastVector[ 0 ] * newVector[ 1 ] - newVector[ 0 ] * lastVector[ 1 ],\n      lastVector[ 0 ] * newVector[ 0 ] + lastVector[ 1 ] * newVector[ 1 ]\n    )\n\n    this.setAngle(this.getAngle() + angle)\n    this.dispatchRotatingEvent_(this.features_)\n\n    this.lastCoordinate_ = coordinate\n  }\n  // handle drag of the anchor\n  else if (this.anchorMoving_) {\n    this.setAnchor(coordinate)\n  }\n}\n\n/**\n * @param {ol.MapBrowserEvent} evt Event.\n * @return {boolean}\n * @this {RotateFeatureInteraction}\n * @private\n */\nfunction handleMoveEvent ({ map, pixel }) {\n  const elem = map.getTargetElement()\n  const foundFeature = map.forEachFeatureAtPixel(pixel, identity)\n\n  const setCursor = (cursor, vendor = false) => {\n    if (vendor) {\n      elem.style.cursor = '-webkit-' + cursor\n      elem.style.cursor = '-moz-' + cursor\n    }\n\n    elem.style.cursor = cursor\n  }\n\n  if (this.lastCoordinate_) {\n    this.previousCursor_ = elem.style.cursor\n    setCursor('grabbing', true)\n  } else if (\n    foundFeature &&\n    (\n      includes(this.features_.getArray(), foundFeature) ||\n      foundFeature === this.arrowFeature_\n    )\n  ) {\n    this.previousCursor_ = elem.style.cursor\n    setCursor('grab', true)\n  } else if (( foundFeature && foundFeature === this.anchorFeature_ ) || this.anchorMoving_) {\n    this.previousCursor_ = elem.style.cursor\n    setCursor('crosshair')\n  } else {\n    setCursor(this.previousCursor_ || '')\n    this.previousCursor_ = undefined\n  }\n}\n\n/**\n * @returns {StyleFunction}\n * @private\n */\nfunction getDefaultStyle () {\n  const white = [ 255, 255, 255, 0.8 ]\n  const blue = [ 0, 153, 255, 0.8 ]\n  const transparent = [ 255, 255, 255, 0.01 ]\n  const width = 2\n\n  const styles = {\n    [ ANCHOR_KEY ]: [\n      new Style({\n        image: new RegularShape({\n          fill: new Fill({\n            color: [ 0, 153, 255, 0.8 ]\n          }),\n          stroke: new Stroke({\n            color: blue,\n            width: 1\n          }),\n          radius: 4,\n          points: 6\n        }),\n        zIndex: Infinity\n      })\n    ],\n    [ ARROW_KEY ]: [\n      new Style({\n        fill: new Fill({\n          color: transparent\n        }),\n        stroke: new Stroke({\n          color: white,\n          width: width + 2\n        }),\n        text: new Text({\n          font: '12px sans-serif',\n          offsetX: 20,\n          offsetY: -20,\n          fill: new Fill({\n            color: 'blue'\n          }),\n          stroke: new Stroke({\n            color: white,\n            width: width + 1\n          })\n        }),\n        zIndex: Infinity\n      }),\n      new Style({\n        fill: new Fill({\n          color: transparent\n        }),\n        stroke: new Stroke({\n          color: blue,\n          width\n        }),\n        zIndex: Infinity\n      })\n    ]\n  }\n\n  return function (feature, resolution) {\n    let style\n    const angle = feature.get(ANGLE_PROP) || 0\n\n    switch (true) {\n      case feature.get(ANCHOR_KEY):\n        style = styles[ ANCHOR_KEY ]\n        style[ 0 ].getImage().setRotation(-angle)\n\n        return style\n      case feature.get(ARROW_KEY):\n        style = styles[ ARROW_KEY ]\n\n        const coordinates = feature.getGeometry().getCoordinates()\n        // generate arrow polygon\n        const geom = new Polygon([\n          [\n            [ coordinates[ 0 ], coordinates[ 1 ] - 6 * resolution ],\n            [ coordinates[ 0 ] + 8 * resolution, coordinates[ 1 ] - 12 * resolution ],\n            [ coordinates[ 0 ], coordinates[ 1 ] + 30 * resolution ],\n            [ coordinates[ 0 ] - 8 * resolution, coordinates[ 1 ] - 12 * resolution ],\n            [ coordinates[ 0 ], coordinates[ 1 ] - 6 * resolution ],\n          ]\n        ])\n\n        // and rotate it according to current angle\n        geom.rotate(angle, coordinates)\n        style[ 0 ].setGeometry(geom)\n        style[ 1 ].setGeometry(geom)\n        style[ 0 ].getText().setText(Math.round(-angle * 180 / Math.PI) + '°')\n\n        return style\n    }\n  }\n}\n\n/**\n * @param {ol.Collection<ol.Feature>|Array<ol.Feature>} features\n * @returns {ol.Extent | undefined}\n * @private\n */\nfunction getFeaturesExtent (features) {\n  features = features instanceof Collection ? features.getArray() : features\n  if (!features.length) return\n\n  return new GeometryCollection(features.map(feature => feature.getGeometry())).getExtent()\n}\n\n/**\n * @param {ol.Collection<ol.Feature> | Array<ol.Feature>} features\n * @return {ol.Coordinate | undefined}\n */\nfunction getFeaturesCentroid (features) {\n  features = features instanceof Collection ? features.getArray() : features\n  if (!features.length) return\n\n  return extentHelper.getCenter(getFeaturesExtent(features))\n}\n","/**\n * Rotate interaction for OpenLayers.\n * Allows vector feature rotation.\n *\n * @author Vladimir Vershinin <ghettovoice@gmail.com>\n * @licence MIT https://opensource.org/licenses/MIT\n * @copyright (c) 2016-2017, Vladimir Vershinin\n */\nimport RotateFeatureInteraction from \"./interaction\"\n\n// for backward compatibility\nif (typeof window !== 'undefined' && window.ol) {\n  window.ol.interaction.RotateFeature = RotateFeatureInteraction\n}\n\nexport default RotateFeatureInteraction\n"],"names":["assert","condition","message","join","Error","identity","arg","includes","arr","value","indexOf","isArray","val","Object","prototype","toString","RotateFeatureEventType","RotateFeatureEvent","type","features","angle","anchor","propagationStopped_","type_","features_","angle_","anchor_","this","ANCHOR_KEY","ARROW_KEY","ANGLE_PROP","ANCHOR_PROP","RotateFeatureInteraction","options","white","blue","transparent","styles","handleEvent","handleDownEvent","handleUpEvent","handleDragEvent","handleMoveEvent","previousCursor_","undefined","anchorFeature_","arrowFeature_","lastCoordinate_","anchorMoving_","overlay_","VectorLayer","style","Style","RegularShape","Fill","Stroke","Infinity","width","Text","feature","resolution","get","getImage","setRotation","coordinates","getGeometry","getCoordinates","geom","Polygon","rotate","setGeometry","getText","setText","Math","round","PI","VectorSource","Collection","setAnchor","getFeaturesCentroid","_this","setAngle","on","onFeatureAdd_","onFeatureRemove_","onAngleChange_","onAnchorChange_","createOrUpdateAnchorFeature_","createOrUpdateArrowFeature_","PointerInteraction","map","setMap","active","isNaN","parseFloat","set","length","getAngle","getAnchor","setCoordinates","Feature","Point","getSource","addFeature","resetAngle_","resetAnchor_","resetAngleAndAnchor_","getLength","clear","oldValue","forEach","_this2","dispatchEvent","getMap","setActive","getActive","evt","foundFeature","forEachFeatureAtPixel","pixel","getArray","coordinate","dispatchRotateStartEvent_","dispatchRotateEndEvent_","anchorCoordinate","lastVector","newVector","atan2","dispatchRotatingEvent_","elem","getTargetElement","setCursor","cursor","extentHelper","getCenter","GeometryCollection","getExtent","getFeaturesExtent","window","ol","interaction","RotateFeature"],"mappings":"iQAKA,SAAgBA,EAAQC,OAAWC,yDAAU,SAC/B,mBAAoBA,GAAUC,KAAK,OAE1CF,QACG,IAAIG,MAAMF,GAQpB,SAAgBG,EAAUC,UACjBA,EAuBT,SAAgBC,EAAUC,EAAKC,UACE,IAAxBD,EAAIE,QAAQD,GAGrB,SAAgBE,EAASC,SACqB,mBAAhCC,OAAOC,UAAUC,2nCC3ClBC,EAKJ,cALIA,EAUD,WAVCA,EAeN,YAScC,wBAONC,EAAMC,EAAUC,EAAOC,kBAK7BC,qBAAsB,OAOtBC,MAAQL,OAORM,UAAYL,OAMZM,OAASL,OAMTM,QAAUL,0DA0CVC,qBAAsB,iDAOtBA,qBAAsB,oDA1CpBK,KAAKL,wDAOLK,KAAKJ,8CAOLI,KAAKH,+CAOLG,KAAKF,6CAOLE,KAAKD,oQC9EVE,EAAa,gBACbC,EAAY,eAEZC,EAAa,QACbC,EAAc,SAKCC,+BAINC,4EA2gBPC,EACAC,EACAC,EAGAC,0EA9gBWC,kBACIC,gBACFC,kBACEC,kBACAC,UAMdC,qBAAkBC,IAKlBC,oBAAiBD,IAKjBE,mBAAgBF,IAKhBG,qBAAkBH,IAKlBI,eAAgB,IAKhBC,SAAW,IAAIC,SACXjB,EAAQkB,QAqebjB,GAAU,IAAK,IAAK,IAAK,IACzBC,GAAS,EAAG,IAAK,IAAK,IACtBC,GAAgB,IAAK,IAAK,IAAK,YAIjCR,GACA,IAAIwB,SACK,IAAIC,QACH,IAAIC,UACC,EAAG,IAAK,IAAK,aAEhB,IAAIC,SACHpB,QACA,WAED,SACA,WAEFqB,EAAAA,UAGV3B,GACA,IAAIuB,QACI,IAAIE,SACDlB,WAED,IAAImB,SACHrB,QACAuB,SAEH,IAAIC,QACF,0BACG,YACC,QACJ,IAAIJ,SACD,gBAED,IAAIC,SACHrB,QACAuB,aAGHD,EAAAA,IAEV,IAAIJ,QACI,IAAIE,SACDlB,WAED,IAAImB,SACHpB,QA/CD,WAkDAqB,EAAAA,MAhDRnB,IAqDC,SAAUsB,EAASC,OACpBT,SACE/B,EAAQuC,EAAQE,IAAI/B,IAAe,UAEjC,QACD6B,EAAQE,IAAIjC,YACPS,EAAQT,IACT,GAAIkC,WAAWC,aAAa3C,GAE5B+B,OACJQ,EAAQE,IAAIhC,KACPQ,EAAQR,OAEVmC,EAAcL,EAAQM,cAAcC,iBAEpCC,EAAO,IAAIC,KAEXJ,EAAa,GAAKA,EAAa,GAAM,EAAIJ,IACzCI,EAAa,GAAM,EAAIJ,EAAYI,EAAa,GAAM,GAAKJ,IAC3DI,EAAa,GAAKA,EAAa,GAAM,GAAKJ,IAC1CI,EAAa,GAAM,EAAIJ,EAAYI,EAAa,GAAM,GAAKJ,IAC3DI,EAAa,GAAKA,EAAa,GAAM,EAAIJ,eAK1CS,OAAOjD,EAAO4C,KACZ,GAAIM,YAAYH,KAChB,GAAIG,YAAYH,KAChB,GAAII,UAAUC,QAAQC,KAAKC,MAAe,KAARtD,EAAcqD,KAAKE,IAAM,KAE3DxB,YA7jBD,IAAIyB,YACA,IAAIC,QAObrD,eAAYoB,EACbX,EAAQd,YACNR,EAAQsB,EAAQd,YACbK,UAAY,IAAIqD,EAAW5C,EAAQd,cACnC,CAAA,KAAIc,EAAQd,oBAAoB0D,SAG/B,IAAIzE,MAAM,uEACiB6B,EAAQd,aAHpCK,UAAYS,EAAQd,gBAMtBK,UAAY,IAAIqD,WAGlBC,UAAU7C,EAAQZ,QAAU0D,EAAoBC,EAAKxD,cACrDyD,SAAShD,EAAQb,OAAS,KAE1BI,UAAU0D,GAAG,MAASF,EAAKG,yBAC3B3D,UAAU0D,GAAG,SAAYF,EAAKI,4BAC9BF,GAAG,UAAYpD,EAAckD,EAAKK,0BAClCH,GAAG,UAAYnD,EAAeiD,EAAKM,2BAEnCC,iCACAC,mWA1E6CC,qCA+I5CC,QACDzC,SAAS0C,OAAOD,wFACRA,qCAMJE,GACLjE,KAAKsB,eACFA,SAAS0C,OAAOC,EAASjE,KAAK+D,SAAM9C,2FAG3BgD,oCAQRxE,MACAyE,MAAMC,WAAW1E,IAAS,6BAE7B2E,IAAIjE,EAAYgE,WAAW1E,8CASzBO,KAAKkC,IAAI/B,qCAQPT,KACQ,MAAVA,GAAkBV,EAAQU,IAA6B,IAAlBA,EAAO2E,OAAc,qCAE5DD,IAAIhE,EAAuB,MAAVV,EAAiBA,EAAOqE,IAAII,YAAcf,EAAoBpD,KAAKH,uDASlFG,KAAKkC,IAAI9B,gEAOVX,EAAQO,KAAKsE,WACb5E,EAASM,KAAKuE,YAEf7E,IAEDM,KAAKkB,qBACFA,eAAeoB,cAAckC,eAAe9E,QAC5CwB,eAAekD,IAAIjE,EAAYV,UAE/ByB,eAAiB,IAAIuD,eACd,IAAIC,EAAMhF,QAClBS,EAAcV,OACdQ,GAAc,YAEbqB,SAASqD,YAAYC,WAAW5E,KAAKkB,8EAQtCzB,EAAQO,KAAKsE,WACb5E,EAASM,KAAKuE,YAEf7E,IAEDM,KAAKmB,oBACFA,cAAcmB,cAAckC,eAAe9E,QAC3CyB,cAAciD,IAAIjE,EAAYV,UAE9B0B,cAAgB,IAAIsD,eACb,IAAIC,EAAMhF,QAClBS,EAAcV,OACdS,GAAa,YAEZoB,SAASqD,YAAYC,WAAW5E,KAAKmB,qEAQvC0D,mBACAC,0DAOAV,IAAIjE,EAAY,GAAG,QACnBgB,eAAiBnB,KAAKmB,cAAciD,IAAIjE,EAAYH,KAAKsE,iBACzDpD,gBAAkBlB,KAAKkB,eAAekD,IAAIjE,EAAYH,KAAKsE,wDAO3DF,IAAIhE,EAAagD,EAAoBpD,KAAKH,YAAY,GAEvDG,KAAKuE,mBACFpD,eAAiBnB,KAAKmB,cAAcmB,cAAckC,eAAexE,KAAKuE,kBACtErD,gBAAkBlB,KAAKkB,eAAeoB,cAAckC,eAAexE,KAAKuE,2DAQ1EQ,4BACAnB,oCACAC,8EAOAkB,uBAED/E,KAAKH,UAAUmF,kBACZpB,oCACAC,qCAEAvC,SAASqD,YAAYM,aACrB/D,eAAiBlB,KAAKmB,mBAAgBF,wDAO9BiE,IAAAA,cACVrF,UAAUsF,QAAQ,mBAAWnD,EAAQM,cAAcI,OAAO0C,EAAKd,WAAaY,EAAUE,EAAKb,oBAC3FpD,eAAiBnB,KAAKmB,cAAciD,IAAIjE,EAAYH,KAAKsE,iBACzDpD,gBAAkBlB,KAAKkB,eAAekD,IAAIjE,EAAYH,KAAKsE,0DAO1D5E,EAASM,KAAKuE,YAEhB7E,SACGwB,gBAAkBlB,KAAKkB,eAAeoB,cAAckC,eAAe9E,QACnEyB,eAAiBnB,KAAKmB,cAAcmB,cAAckC,eAAe9E,sDAQ/CF,QACpB6F,cACH,IAAI/F,EACFD,EACAG,EACAQ,KAAKsE,WACLtE,KAAKuE,6DASa/E,QACjB6F,cACH,IAAI/F,EACFD,EACAG,EACAQ,KAAKsE,WACLtE,KAAKuE,8DASc/E,QAClB6F,cACH,IAAI/F,EACFD,EACAG,EACAQ,KAAKsE,WACLtE,KAAKuE,sDApRFvE,KAAKH,+CAOLG,KAAKsE,yBAMH7E,QACJ6D,SAAS7D,yCAOPO,KAAKuE,0BAMF7E,QACLyD,UAAUzD,6BAMRqE,QACFC,OAAOD,0BAOL/D,KAAKsF,sCAMFrB,QACLsB,UAAUtB,0BAORjE,KAAKwF,qBAkOhB,SAMS7E,EAAa8E,OAEdC,EAAeD,EAAI1B,IAAI4B,sBAAsBF,EAAIG,MAAOlH,WAE5DE,GAAW,QAAS,cAAe,YAAc6G,EAAIlG,QACrDX,GAAWoB,KAAKkB,eAAgBlB,KAAKmB,eAAiBuE,KAK3C5B,EAAmBnD,sBAAY8E,GAS9C,SAAS7E,EAAiB6E,OAClBC,EAAeD,EAAI1B,IAAI4B,sBAAsBF,EAAIG,MAAOlH,UAI5DgH,GAAiB1F,KAAKoB,kBAEpBxC,EAASoB,KAAKH,UAAUgG,WAAYH,IACpCA,IAAiB1F,KAAKmB,iBAWjBuE,GAAgBA,IAAiB1F,KAAKkB,uBACxCG,eAAgB,cACCoE,IAEf,SAZFrE,gBAAkBqE,EAAIK,uBAELL,QACjBM,0BAA0B/F,KAAKH,YAE7B,GAmBX,SAASgB,EAAe4E,UAElBzF,KAAKoB,sBACFA,qBAAkBH,cAEDwE,QACjBO,wBAAwBhG,KAAKH,YAE3B,KAGAG,KAAKqB,qBACPA,eAAgB,cACCoE,IAEf,GAYX,SAAS3E,SAAmBgF,IAAAA,WACpBG,EAAmBjG,KAAKkB,eAAeoB,cAAcC,oBAGvDvC,KAAKoB,gBAAiB,KAElB8E,GACJlG,KAAKoB,gBAAiB,GAAM6E,EAAkB,GAC9CjG,KAAKoB,gBAAiB,GAAM6E,EAAkB,IAE1CE,GACJL,EAAY,GAAMG,EAAkB,GACpCH,EAAY,GAAMG,EAAkB,IAIlCxG,EAAQqD,KAAKsD,MACfF,EAAY,GAAMC,EAAW,GAAMA,EAAW,GAAMD,EAAY,GAChEA,EAAY,GAAMC,EAAW,GAAMD,EAAY,GAAMC,EAAW,SAG7D7C,SAAStD,KAAKsE,WAAa7E,QAC3B4G,uBAAuBrG,KAAKH,gBAE5BuB,gBAAkB0E,OAGhB9F,KAAKqB,oBACP8B,UAAU2C,GAUnB,SAAS/E,SAAmBgD,IAAAA,IAAK6B,IAAAA,MACzBU,EAAOvC,EAAIwC,mBACXb,EAAe3B,EAAI4B,sBAAsBC,EAAOlH,GAEhD8H,EAAY,SAACC,+DAEVjF,MAAMiF,OAAS,WAAaA,IAC5BjF,MAAMiF,OAAS,QAAUA,KAG3BjF,MAAMiF,OAASA,GAGlBzG,KAAKoB,sBACFJ,gBAAkBsF,EAAK9E,MAAMiF,SACxB,YAAY,IAEtBf,IAEE9G,EAASoB,KAAKH,UAAUgG,WAAYH,IACpCA,IAAiB1F,KAAKmB,qBAGnBH,gBAAkBsF,EAAK9E,MAAMiF,SACxB,QAAQ,IACPf,GAAgBA,IAAiB1F,KAAKkB,gBAAoBlB,KAAKqB,oBACrEL,gBAAkBsF,EAAK9E,MAAMiF,SACxB,iBAEAzG,KAAKgB,iBAAmB,SAC7BA,qBAAkBC,GAuH3B,SAASmC,EAAqB5D,SACjBA,aAAoB0D,EAAa1D,EAASqG,WAAarG,GACpD6E,cAEPqC,EAAaC,UAftB,SAA4BnH,SACfA,aAAoB0D,EAAa1D,EAASqG,WAAarG,GACpD6E,cAEP,IAAIuC,EAAmBpH,EAASuE,IAAI,mBAAW/B,EAAQM,iBAAgBuE,YAWhDC,CAAkBtH,UCrpB5B,oBAAXuH,QAA0BA,OAAOC,YACnCA,GAAGC,YAAYC,cAAgB7G"}